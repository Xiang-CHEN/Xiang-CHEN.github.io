---
layout: post
title: 数据结构（未完成）
date: 2015-06-22
categories: 下拉电阻
tag: 算法
---

# 线性结构

|操作| 顺序表 | 单链表 |
|:---:|:---:|:---:|
|构造|$O(1)$|$O(1)$|
|销毁|$O(1)$|$O(n)$|
|取元|$O(1)$|$O(n)$|
|插入|$O(n)$|$O(1)$|
|删除|$O(n)$|$O(1)$|
|优点|可随机存取|插入删除快，空间效率高|

稀疏矩阵：三元组，十字链表

| 比较 | 顺序栈 | 链式栈 |
|:---:|:---:|:---:|
|空间|需要初始化，空间利用率低|无需初始化，空间利用率高|
|操作|进出栈$O(1)$，清空栈$O(1)$|进出栈$O(1)$，清空栈$O(n)$|
为了提高顺序栈和顺序队列的空间利用效率，可以将顺序栈做成双栈，将顺序队列做成循环队列

# 树

树的性质

- 节点数目=节点度数和加1
- 二叉树叶子节点个数=度为2节点个数+1
- 完全二叉树左孩子2n+1右孩子2n+2

完全二叉树可用顺序存储

二叉树遍历，非递归

先中后序：栈；层序：队列

左孩子右兄弟，先跟->先序，后跟->中序

# 堆

- 自顶向下堆化：$O(h)$
- 自底向上堆化：$O(h)$
- 自顶向下堆构造：$O(N\log N)$
- 自底向上堆构造：$O(N)$

# 图

连通性 路径 传递闭包warshall，$O(v^3)$

有向无环图，调度，拓扑排序（检验环）

邻接矩阵 邻接表

遍历：DFS，BFS

最小生成树MST：Prim，$O(v^2)$，适合稠密图；Kruskal，$O(E\log E)$，适合稀疏图

最短路径树SPT：Dijkstra，$O(v^2)$；负权，Bellman-Ford，$O(vE)$，不能有负环；全源Floyd，$O(v^3)$，允许负权值的边





# 算法：有穷 确定 可行 输入 输出

- 贪心
- 动态规划
-- 要素：阶段，状态，决策
-- 条件：最优子结构，无后效性
-- 适合：用空间换时间，适合有大量重复子问题的问题
- 递归

# 其他
- 字符串匹配
KMP算法：$O(m+n)$（蛮力算法$O(mn)$）
```
void Next(char *P){
	int m = strlen(P);//模式串P的长度
	N[0] = 0;//位置0处的部分匹配串长度为0
	int i = 1; j = 0;//初始化比较位置
	while(i < m){
		if(P[i] == P[j]) {//已经匹配了j＋1个字符
			N[i] = j+1;//部分匹配串长度加一
			i++; j++;//比较位置各进一
			}
		else if( j > 0) j = N[j-1];//移动：用部分匹配串对齐
		else { N[i++] = 0;}//j在串头时部分匹配串长度为0
	}
}
int KMP_match(char *T, char *P){
	int n = strlen(T), m = strlen(P); //目标串和模式串长度
	int i=0, j=0;next(P);//预处理函数
	while (i<n) {
		if (T[i]==P[j]) {//已经匹配j＋1个字符
			if (j = = m-1) return i-j;//匹配成功，返回匹配位置
				else { i++; j++; }//比较下一个位置
		}
		else {
			if (j>0) j = N[j-1];//匹配不成功，移动到部分匹配串
				else i++;//失配
		}
	}
	return -1;//匹配失败
}
```
- 栈混洗数目=合式序列数目=Catalan数
$Cat(n)=C(2n,n)-C(2n,n-1)=\frac{(2n)!}{(n-1)!(n+1)!}$
n对括号的非合式序列数目对应于具有n-1个左括号和n+1右括号构成的所有可能序列的数目
